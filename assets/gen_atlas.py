#!/usr/bin/env python3
import glob
from dataclasses import dataclass
from typing import List

import click
import rectpack
import scipy.signal
from PIL import Image, ImageDraw
from rectpack import newPacker
from rectpack.packer import Packer
import numpy as np


@dataclass
class Vec2:
    x: int
    y: int

    def __iter__(self):
        yield self.x
        yield self.y

    def __add__(self, other):
        x, y = other
        return Vec2(self.x + x, self.y + y)


class Sprite:
    def __init__(self, file=""):
        self.file = file
        self.im = Image.open(file)
        self.original_size = self.im.size
        self.content_size = self.im.size
        self.rect_offset = Vec2(0, 0)
        """Wrt original rect"""
        self.content_offset = Vec2(0, 0)
        """Wrt rect"""

    @property
    def rect_size(self):
        return self.im.size

    @property
    def total_offset(self):
        return self.rect_offset + self.content_offset

    def trim(self):
        """Trim an image and return the offset (shift+original size)"""
        self.fix_alpha((0, 0, 0))
        before = self.im.size[1]
        box = self.im.getbbox()
        self.im = self.im.crop(box)

        self.rect_offset.x += box[0]
        self.rect_offset.y += before - box[1] - self.im.size[1]
        self.content_size = self.im.size

        return self

    def fix_alpha(self, rgb=(255, 255, 255)):
        # extend where there is transparency
        pix = np.array(self.im.convert("RGBA"))
        pix[pix[..., 3] == 0] = (*rgb, 0)
        self.im = Image.fromarray(pix)

        return self

    def fix_border(self):
        im = np.array(self.im).astype(np.int32)
        ker = np.ones((3, 3))
        s = scipy.signal.convolve2d(im[..., 3], ker, mode="same")
        trans_border = ((im[..., 3] == 0) * (s > 0))[1:-1, 1:-1]
        s = s[1:-1, 1:-1]
        r = scipy.signal.convolve2d(im[..., 0] * im[..., 3], ker, mode="valid") / s
        g = scipy.signal.convolve2d(im[..., 1] * im[..., 3], ker, mode="valid") / s
        b = scipy.signal.convolve2d(im[..., 2] * im[..., 3], ker, mode="valid") / s
        im[1:-1, 1:-1, 0][trans_border] = r[trans_border]
        im[1:-1, 1:-1, 1][trans_border] = g[trans_border]
        im[1:-1, 1:-1, 2][trans_border] = b[trans_border]
        self.im = Image.fromarray(im.astype(np.int8), mode="RGBA")

    def extrude(self, ex: int):
        """Expand an image of `ex` pixels on each side, stretching the border"""
        if ex <= 0:
            return

        w, h = self.im.size
        new = self.im.crop((-ex, -ex, w + ex, h + ex))
        nw, nh = new.size
        self.content_offset += ex, ex
        self.content_size = Vec2(w, h)

        # Extend the side
        left = self.im.crop((0, 0, 1, h))
        right = self.im.crop((w - 1, 0, w, h))
        top = self.im.crop((0, 0, w, 1))
        bottom = self.im.crop((0, h - 1, w, h))
        for d in range(ex):
            new.paste(left, (d, ex, d + 1, ex + h))
            new.paste(right, (nw - d - 1, ex, nw - d, ex + h))
            new.paste(top, (ex, d, ex + w, d + 1))
            new.paste(bottom, (ex, nh - d - 1, ex + w, nh - d))

        # Extend the corners
        draw = ImageDraw.Draw(new)
        draw.rectangle((0, 0, ex, ex), self.im.getpixel((0, 0)))  # top-left
        draw.rectangle((nw - ex, 0, nw, ex), self.im.getpixel((w - 1, 0)))  # top-right
        draw.rectangle(
            (0, nh - ex, ex, nh), self.im.getpixel((0, h - 1))
        )  # bottom-left
        draw.rectangle(
            (nw - ex, nh - ex, nw, nh), self.im.getpixel((w - 1, h - 1))
        )  # bottom-right

        self.im = new

        self.fix_border()

        return self

    def content_rect(self, rect_x, rect_y):
        return tuple(self.content_offset + Vec2(rect_x, rect_y)) + tuple(
            self.content_size
        )

    def python_enum_name(self) -> str:
        name = self.file.rpartition("/")[2].partition(".")[0].replace("-", "_").upper()

        return name

    def as_tuple(self, pos):
        return (*self.content_rect(*pos), *self.total_offset, *self.original_size)


def gen_py_string(bin: rectpack.MaxRectsBssf, images: List[Sprite]):
    TEMPLATE = r'''# This file is generated by [gen_atlas.py]

import enum
from functools import lru_cache

TEX_WIDTH = WW
TEX_HEIGHT = HH

RECTS = [
    #   x,    y,    w,    h, offx, offy, orgw, orgh 
    BUFFER
]
"""
Coordinates of the rectangles of each image in the atlas.
The coordinates increase left and up, as in a standard RÂ²
coordinate system. 
Each tuple cooresponds to height numbers, in order:
    - the left coordinate of the sprite
    - the bottom coordinate
    - the with of the sprite
    - the height of the sprite
    - the x offset of the sprite in the original image
    - the y offset of the sprite in the original image
    - the width of the original image
    - the height of the original image
"""


class Sprite(enum.Enum):
    ENUM
    
    
class Anim(enum.Enum):
    ANIM
'''

    # size
    width = bin.width
    height = bin.height

    # buffer
    buffer = [
        ("(" + ", ".join(("{:<{s}}",) * 8) + "),  # {i}: {name}").format(
            *images[i].as_tuple((rect.x, rect.y)),
            s=4,
            i=i,
            name=images[i].python_enum_name(),
        )
        for i, rect in enumerate(sorted(bin, key=lambda rect: rect.rid))
    ]
    buffer_sep = "\n" + " " * 4  # one tab
    buffer_str = buffer_sep.join(buffer)

    # enum
    enum_sep = "\n" + " " * 4  # one tab
    names = list(map(Sprite.python_enum_name, images))
    enum_str = enum_sep.join(f"{name} = {i}" for (i, name) in enumerate(names))

    # anim
    anims = {}
    for i, name in enumerate(names):
        n, _, idx = name.rpartition("_")
        if idx.isdecimal():
            a = anims.get(n, {})
            a[idx] = i
            anims[n] = a
    for anim_name, anim in anims.items():
        anims[anim_name] = tuple(i for (_, i) in sorted(anim.items()))
    sep = "\n" + " " * 4
    anim_str = sep.join(f"{name} = {frames}" for name, frames in anims.items())

    code = (
        TEMPLATE.replace("BUFFER", buffer_str)
        .replace("ENUM", enum_str)
        .replace("WW", str(width))
        .replace("HH", str(height))
        .replace("ANIM", anim_str)
    )

    return code


def combine(bin: rectpack.MaxRectsBssf, images: List[Sprite]) -> Image.Image:
    """Combine a list of images into an atlas, according to the rects positions"""
    bw, bh = bin.width, bin.height
    atlas = Image.new("RGBA", (bin.width, bin.height))

    for rect in bin:
        x, y = rect.x, bh - rect.y
        atlas.paste(images[rect.rid].im, (x, y - rect.height, x + rect.width, y))

    return atlas


@click.command()
@click.option(
    "--extrude", default=0, help="Expend the imagepast the border of N pixels"
)
@click.argument("files", nargs=-1)
@click.option("--py-out", default="atlas.py")
@click.option("--img-out", default="atlas.png")
@click.option("--trim", is_flag=True, help="Remove whitespace around the image.")
@click.option("--atlas-size", default=(2 ** 11,) * 2)
@click.option("--fix-alpha", is_flag=True, help="Set all transparent pixels to #fff0")
def main(files, extrude, trim, img_out, py_out, atlas_size, fix_alpha):
    """Pack sprites into a single atlas."""
    files = sorted([f for file in files for f in glob.glob(file)])
    print("Files", *files, sep="\n")
    images = [Sprite(file) for file in files]

    if trim:
        print("Trimming...")
        images = map(Sprite.trim, images)

    if fix_alpha:
        print("Fixing alpha...")
        images = map(Sprite.fix_alpha, images)

    if extrude:
        print("Extruding")
        images = [im.extrude(extrude) for im in images]

    images = list(images)

    # Packer setup
    print("Packing...")
    packer: Packer = newPacker(rotation=False)
    for i, im in enumerate(images):
        packer.add_rect(*im.rect_size, i)
    packer.add_bin(*atlas_size)

    # Pack all the images in the atlas
    packer.pack()
    missing = len(files) - len(packer[0])
    assert missing == 0, f"Unable to pack everything. {missing} images missing"
    print("Combining...")
    atlas = combine(packer[0], images)

    # Output
    print("Saving...")
    atlas.save(img_out)
    py = gen_py_string(packer[0], images)
    with open(py_out, "w") as f:
        f.write(py)


if __name__ == "__main__":
    main()
